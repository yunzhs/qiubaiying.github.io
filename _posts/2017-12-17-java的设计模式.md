---
layout:     post
title:      java的设计模式
date:       2017-12-17
author:     yunzhs
header-img: img/Fate of Princess.jpg
catalog: true
tags:
    - java的设计模式
    - java
typora-root-url: ..
typora-copy-images-to: ..\img\posts
---

## Java有23种设计模式,如单例,适配器,工厂,装饰类.

## 装饰类:

bufferedreader就是典型的装饰类,原理是把引用类丢进去,然后对其的功能进行升级,~~对想要抛弃的方法不进行实现~~,起到一个完美的装饰效果,普通学生经过学校培训后,学生原有的属性不发生改变,但是其知识却被增强了.

```
A+是A方法的装饰类
public void A+ extend A(){
  public A(){
    super();
  }
  public void method1(){
  }
  public void method2(){
  }
  public void method3(){
  }  
}
```



## 适配器:

就是创建一个实现类,实现接口中的所有方法,再让其他类去继承,这样就不用实现所有抽象类,只要实现有用的即可.

## 工厂模式:

工厂模式就是提供一个工厂方法，传入指定的参数得到我想要的对象。用工厂方法代替new操作的一种模式.

```
public class Test {
	public static void main(String[] args) {
	        FruitsFactory factory = new FruitsFactory();
		Fruits apple = factory.purchaseFruits("Apple");
		apple.describe();
		Fruits banana = factory.purchaseFruits("Banana");
		banana.describe();
	}
}
```

就是根据参数来获得想要的对象。

抽象工厂模式是所有形态的工厂模式中最为抽象和最具一般性的一种形态,相当于下设多个工厂

工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。    工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个,类似于多个产品,每个产品又有不同的品牌代工

```
public abstract class FruitsApple {
	public abstract void describe();
}
public class Apple extends FruitsApple {
	@Override
	public void describe() {
		System.out.println("我是苹果");
	}
}
public abstract class FruitsBanana {
	public abstract void describe();
}
public class Banana extends FruitsBanana {
	@Override
	public void describe() {
		System.out.println("我是香蕉");
	}
}

-----------------------------------------------------------------------

public class BusinessmanAbstractFactory {
	public static FruitsApple createApple(String name) throws InstantiationException, IllegalAccessException, ClassNotFoundException{
		if("".equals(name) || name == null){
			return null;
		}
		return (FruitsApple) Class.forName(name).newInstance();
	}
		public static FruitsBanana createBanana(String name) throws InstantiationException, IllegalAccessException, ClassNotFoundException{
		if("".equals(name) || name == null){
			return null;
		}
		return (FruitsBanana) Class.forName(name).newInstance();
	}
}

------------------------------------------

public class Test {
	public static void main(String[] args) throws InstantiationException, IllegalAccessException, ClassNotFoundException {
		FruitsApple apple = BusinessmanAbstractFactory.createApple("com.newtt.Apple");
		apple.describe();
		FruitsBanana banana = BusinessmanAbstractFactory.createBanana("com.newtt.Banana");
		banana.describe();
	}
}
```

- 抽象工程关键在于产品之间的抽象关系，所以至少要两个产品；工厂方法在于生成产品，不关注产品间的关系，所以可以只生成一个产品。


- 抽象工厂中客户端把产品的抽象关系理清楚，在最终使用的时候，一般使用客户端（和其接口），产品之间的关系是被封装固定的；而工厂方法是在最终使用的时候，使用产品本身（和其接口）。

  抽象工厂更像一个复杂版本的策略模式，策略模式通过更换策略来改变处理方式或者结果；而抽象工厂的客户端，通过更改工厂还改变结果。所以在使用的时候，就使用客户端和更换工厂，而看不到产品本身。

