1、docker的可视化图形工具：Portainer

![v2-3158800935bdbd30a57c2263ac8b5eb4_720w](/Users/gengyiwei/笔记/博客/yunzhs.github.io/img/posts/v2-3158800935bdbd30a57c2263ac8b5eb4_720w.jpeg)

服务器响应给用户的数据通常会很多，由多个数据包组成。但是当服务器响应客户端请求时，客户端必须完整的接收整个返回结果，而不能简单的只取前面几条结果，然后让服务器停止发送。因而在实际开发中，尽量保持查询简单且只返回必需的数据，减小通信间数据包的大小和数量是一个非常好的习惯，这也是查询中尽量避免使用SELECT *以及加上LIMIT限制的原因之

MySQL的查询缓存系统会跟踪查询中涉及的每个表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。正因为如此，在任何的写操作时，MySQL必须将对应表的所有缓存都设置为失效。

1. 任何的查询语句在开始之前都必须经过检查，即使这条SQL语句永远不会命中缓存
2. 如果查询结果可以被缓存，那么执行完成后，会将结果存入缓存，也会带来额外的系统消耗

```
show variables like '%query_cache%';
```

mysql缓存意思不大，主要还是靠redis等应用级别的缓存



#### 具体优化：

1. 通常来说把可为NULL的列改为NOT NULL不会对性能提升有多少帮助，只是如果计划在**列上创建索引，就应该将该列设置为NOT NULL。**
2. 对整数类型指定宽度，比如INT(11)，没有任何卵用。INT使用32位（4个字节）存储空间，那么它的表示范围已经确定，所以**INT(1)和INT(20)对于存储和计算是相同的**。
3. **UNSIGNED表示不允许负值，大致可以使正数的上限提高一倍**。比如TINYINT存储范围是-128 ~ 127，而UNSIGNED TINYINT存储的范围却是0 - 255。
4. **通常来讲，没有太大的必要使用DECIMAL数据类型。**即使是在需要存储财务数据时，仍然可以使用BIGINT。比如需要精确到万分之一，那么可以将数据乘以一百万然后使用BIGINT存储。这样可以避免浮点数计算不准确和DECIMAL精确计算代价高的问题。
5. TIMESTAMP使用4个字节存储空间，DATETIME使用8个字节存储空间。因而，TIMESTAMP只能表示1970 - 2038年，比DATETIME表示的范围小得多，而且TIMESTAMP的值因时区不同而不同。
6. 大多数情况下没有使用枚举类型的必要，其中一个缺点是枚举的字符串列表是固定的，添加和删除字符串（枚举选项）必须使用ALTER TABLE（如果只只是在列表末尾追加元素，不需要重建表）。
7. schema的列不要太多。原因是存储引擎的API工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各个列，这个转换过程的代价是非常高的。**如果列太多而实际使用的列又很少的话，有可能会导致CPU占用过高。**



#### 索引的数据结构

B +树，多路搜索树     二叉查找树===>二叉平衡树===>多路搜索树（B+树）

![v2-fd647a4bec0ff4b2ae99c76f440927b5_720w](/Users/gengyiwei/笔记/博客/yunzhs.github.io/img/posts/v2-fd647a4bec0ff4b2ae99c76f440927b5_720w.jpeg)

Unique Index和一般normal Index没有显著性的差异