---
typora-root-url: ..
typora-copy-images-to: ..\img\posts
---



## 电商概念SPU与SKU

- SPU = Standard Product Unit （标准产品单位）

SPU是商品信息聚合的最小单位，是一组可复用、易检索的标准化信息的集合，该集合描述了一个产品的特性。
通俗点讲，属性值、特性相同的商品就可以称为一个SPU。

例如：
iphone7就是一个SPU，与商家，与颜色、款式、套餐都无关。



- SKU=stock keeping unit(库存量单位)

SKU即库存进出计量的单位， 可以是以件、盒、托盘等为单位。
SKU是物理上不可分割的最小存货单元。在使用时要根据不同业态，不同管理模式来处理。在服装、鞋类商品中使用最多最普遍。

例如：
纺织品中一个SKU通常表示：规格、颜色、款式。





JS的深度克隆:

是通过这样下列的代码来实现对象之间的引用消除,如果不消除,在其中一个对象改变时,另一个对象就会发生改变
```
var newRow= JSON.parse( JSON.stringify( oldRow )  );//深克隆
//JSON.stringify()将对象转换为文本
```

另外,Json赋给js的变量会自动变为一个对象变量












```
    $scope.findItemCatList=function(){
        itemCatService.findAll().success(
            function(response){
                for(var i=0;i<response.length;i++){
                    $scope.itemCatList[response[i].id]=response[i].name;
            }
            }// itemCatMapper.selectByExample(null);在imp中执行的sql语句
        );
    }
```

在数据库的表中删除数据后,~~相应数据仍会在表中占位,在mybatis的select中~~, 数据库中删除数据后,response的长度不会发生改变,猜测可能是与mybatis的封装有关,或者是数据库的条件有关?



idea中抽取方法:shift+alt +m再选中正确的方法域即可



![Snipaste_2018-01-18_17-47-53](C:/Users/hasee/Pictures/Snipaste_2018-01-18_17-47-53.png)







archetypeCatalog表示插件使用的archetype元数据，不加这个参数时默认为remote，local，即中央仓库archetype元数据，由于中央仓库的archetype太多了，所以导致很慢，指定internal来表示仅使用内部元数据。![Snipaste_2018-01-18_18-01-07](C:/Users/hasee/Pictures/Snipaste_2018-01-18_18-01-07.png)



idea里spring的配置文件貌似也是得相互依赖才能使用



这不写超时就直接给我报错了,我也是醉了

![Snipaste_2018-01-21_23-29-33](/img/posts/Snipaste_2018-01-21_23-29-33.png)



map.putAll(map1) ==> 将一个map集合添加到另一个map集合中





### 实现一个分页的算法

前端用bootstrap来实现,这里只显示五个页码,在页面上显示的五个页码值需要我们用算法是获取,这里我们要求是百度风格的分页

用后端回显的数据可以将其实现.这里把相关的代码贴上

```
<nav aria-label="Page navigation">
  <ul class="pagination">
    <li>
      <a href="#" aria-label="Previous">
        <span aria-hidden="true">&laquo;</span>
      </a>
    </li>
    <li><a href="#">1</a></li>
    <li><a href="#">2</a></li>
    <li>
      <a href="#" aria-label="Next">
        <span aria-hidden="true">&raquo;</span>
      </a>
    </li>
  </ul>
</nav>
```

后端需要一个**当前的页数**,以及**每页显示数据的个数.**

然后根据这两个数据自动返回**所选当前页的数据**和**总页数**和**总数据数**

算法:用java语句来实现吧

```
int pageNo;//当前页
int pageTotal; //总页数
//这两个值是我们当前的已获取数据,假设已赋值
int firstPage; 
int lastPage;

if(pageTotal>5){
  if(pageNo<=3){
  	firstPage=1;
  	lastPage=5;  		
  } //在前半部
  else if(pageNo>=pageTotal-2){
    lastPage=pageTotal;
    firstPage=pageTotal-4;
  }  //在后半部
  else{
    firstPage=pageNo-2;
    lastPage=pageNo+2;
  }  //在中部
}
else{
  firstPage=1;
  lastPage=pageTotal;
}
for(int i=firstPage;i<=lastPage;i++){
  list.add(i) //添加到一个list集合中
}

```



```
Arrays.asList()  //把数组转换成List
```



linux 命令chmod 755的意思

chmod是[Linux](http://lib.csdn.net/base/linux)下设置文件权限的命令，后面的数字表示不同用户或用户组的权限。

一般是三个数字：
第一个数字表示文件所有者的权限
第二个数字表示与文件所有者同属一个用户组的其他用户的权限
第三个数字表示其它用户组的权限。

​      权限分为三种：读（r=4），写（w=2），执行（x=1） 。 综合起来还有可读可执行（rx=5=4+1）、可读可写（rw=6=4+2）、可读可写可执行(rwx=7=4+2+1)。

​      所以，chmod 755 设置用户的权限为： 

1.文件所有者可读可写可执行                                    --7

2.与文件所有者同属一个用户组的其他用户可读可执行 --5 
3.其它用户组可读可执行                                          --5



内部类中不能使用外部定义的变量,想要使用外部的变量必须要将该变量定义为final类型





为什么要用消息中间件JMS方案,原因:在分布式项目中,一个web工程依赖了太多的service,无论是大的小的service,一旦挂掉了一个就都无法使用,因此使用了这个技术,可以在某些时候直接关掉某些服务也不会影响主web的运行,正如阿里双十一,就会关掉评论和一些社交系统来减小服务器的压力



Math.random();返回一个介于0~1之间的数 比如 0.5329322631692659





## 1. 使用redis有哪些好处？

(1) 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1) 
(2) 支持丰富数据类型，支持string，list，set，sorted set，hash 
(3) 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行 
(4) 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除

## mySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据

相关知识：redis 内存数据集大小上升到一定大小的时候，就会施行**数据淘汰策略**。redis 提供 6种数据淘汰策略： 
volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰 
volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰 

可以通过配置通过如下配置控制Redis使用的最大内存：

maxmemory 100mb

在内存占用达到了maxmemory后，再向Redis写入数据时，Redis会：

- 根据配置的数据淘汰策略尝试淘汰数据，释放空间
- 如果没有数据可以淘汰，或者没有配置数据淘汰策略，那么Redis会对所有写请求返回错误，但读请求仍然可以正常执行



`import com.alibaba.dubbo.config.annotation.Service;`

想要把服务上传到dubbo上,必须要把service的注释的包导入成上面那个,不能倒spring自带的那个



location的简单用法:

发送请求端

````
  <a href="goods_edit.html#?id={{entity.id}}" class="btn bg-olive btn-xs">修改</a>
````

接受请求端

```
var id= $location.search()['id'];//获取参数值
```

### 跨域请求解决方案

**跨域请求是什么?**

这里说的js跨域是指通过js在不同的域之间进行数据传输或通信，比如用ajax向一个不同的域请求数据，或者通过js获取页面中不同域的框架中(iframe)的数据。只要协议、域名、端口有任何一个不同，都被当作是不同的域。

**如果不这样,可能会产生资源数据泄露**

```
No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'http://localhost:9100' is therefore not allowed access. The response had HTTP status code 400.
```

**跨域解决方案CORS协议**:

CORS是一个W3C标准，全称是"跨域资源共享"（Cross-origin resource sharing）。CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。

它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。

**请求端代码**:

在前台js代码,controller层

```
  $http.get('http://localhost:9107/cart/addGoodsToCartList.do?itemId='
            + $scope.sku.id +'&num='+$scope.num,{'withCredentials':true})
```

{'withCredentials':true} 表示允许带cookie等凭证过去

**回复端代码**

在后端controller层的相关方法处`CrossOrigin`

```
    @CrossOrigin(origins="http://localhost:9105",allowCredentials="true")
```

ip要写请求端的ip,这是springmvc4之后专门为跨域请求提交而设立的注解



# Result Maps collection already contains value for xxxMapper.BaseResultMap

原因分析
​    Mybatis-Generator在生成Mapper.xml文件时，会在原来基础上再生成，导致内容重复。

解决办法

把原来的删掉再创建新的





短信发送的缓存处理

为什么要用redis而不用session,因为session一个服务器每次会话只能有一个,在生产环境时,我们使用的是ngaix服务器,可能会有多台机器对服务器发起请求,这样如果使用session便不能满足服务器的需求,

同时,为了满足短信验证码的时效功能,我们需要对数据设置时效性,而redis对于时效性的设置易于并且优于session,断网重连后session也会被重置,对用户很不友好

redis 有个setex设置键值 ,可以设置过期时间 PERSIST 则设置为持久的 

ttl可以返回-1表示未设置,返回-2表示已过期





*java中异常的体系是怎么样的呢？*

1.Java中的所有不正常类都继承于Throwable类。Throwable主要包括两个大类，一个是Error类，另一个是Exception类；

　　　　![img](https://images2015.cnblogs.com/blog/1189312/201707/1189312-20170703132225237-1149163416.png)

 2.其中Error类中包括虚拟机错误和线程死锁，一旦Error出现了，程序就彻底的挂了，被称为程序终结者；

　　　![img](https://images2015.cnblogs.com/blog/1189312/201707/1189312-20170703132317972-421341844.png)

3.Exception类，也就是通常所说的“异常”。主要指编码、环境、用户操作输入出现问题，Exception主要包括两大类，非检查异常（RuntimeException）和检查异常（其他的一些异常）

　　　　![img](https://images2015.cnblogs.com/blog/1189312/201707/1189312-20170703132540112-2053625299.png)

4.RuntimeException异常主要包括以下四种异常（其实还有很多其他异常，这里不一一列出）：空指针异常、数组下标越界异常、类型转换异常、算术异常。RuntimeException异常会由java虚拟机自动抛出并自动捕获**（就算我们没写异常捕获语句运行时也会抛出错误！！）**，此类异常的出现绝大数情况是代码本身有问题应该从逻辑上去解决并改进代码。

　　![img](https://images2015.cnblogs.com/blog/1189312/201707/1189312-20170703132648456-1067022743.png)

5.检查异常，引起该异常的原因多种多样，比如说文件不存在、或者是连接错误等等。跟它的“兄弟”RuntimeException运行异常不同，**该异常我们必须手动在代码里添加捕获语句来处理该异常**，这也是我们学习java异常语句中主要处理的异常对象。

　　![img](https://images2015.cnblogs.com/blog/1189312/201707/1189312-20170703133422940-109704620.png)



Oracle遇到的问题

oracle不存在和mysql那样的多个数据库，而是以表空间的形式展示，因此在jdbc连接数据库的时候，不用指定数据库，因为oracle的不同表空间不可能存在相同名字的表，想用啥表直接用就可以了。